# goit-algo-hw-10

## Структура
```
goit-algo-hw-10/
├── coin_change.py
├── coin_change_output.txt
├── monte_carlo_integral.py
├── monte_carlo_output.txt
├── requirements.txt
└── README.md
```

## Завдання 1 — Розмін суми монетами
- `find_coins_greedy(amount, coins)`: жадібний алгоритм — на кожному кроці бере найбільший можливий номінал.
- `find_min_coins(amount, coins)`: динамічне програмування (мінімальна кількість монет).

Обидві функції повертають словник `{номінал: кількість}`. За замовчуванням використовується набір монет `[50, 25, 10, 5, 2, 1]`.

### Як запустити
```bash
python coin_change.py
```
Скрипт виконає самоперевірку та мікро-бенчмарк.

### Пояснення та аналіз складності
- **Greedy**: часова складність `O(m)`, де `m = len(coins)`; памʼять `O(1)`. Для кожного номіналу робимо одну операцію поділу.  
- **DP**: часова складність `O(amount * m)`, памʼять `O(amount)`; будуємо таблицю мінімальної к-сті монет для кожної суми `0..amount`.

Для **канонічних систем монет** (таких, як `[50, 25, 10, 5, 2, 1]`) жадібний алгоритм завжди дає оптимальний розвʼязок (співпадає з DP). Але **не для всіх наборів монет** greedy є оптимальним — для деяких систем потрібен DP, щоб гарантувати мінімум.

### Емпіричне порівняння (приклад)
На 5 000 випадкових сум у діапазоні `[1, 5000]` з монетами `[50,25,10,5,2,1]`:
- Greedy працює в рази швидше (константний час на запит).
- DP повільніший приблизно на порядок, і споживає памʼять `O(amount)`.

**Висновок:**  
- Для великих сум і канонічного набору монет — використовуйте **greedy** (швидше, менше памʼяті).  
- Якщо набір монет довільний або потрібно *гарантовано мінімальну* кількість монет — застосовуйте **DP** (повільніше, але оптимально для будь-якого набору).

## Завдання 2 — Інтеграл методом Монте-Карло
Файл `monte_carlo_integral.py` реалізує оцінку визначеного інтеграла методом Монте‑Карло (схема усереднення значень):
$\int_a^b f(x)\,dx \approx (b-a)\cdot \frac{1}{n}\sum_{i=1}^n f(x_i),\quad x_i\sim U(a,b)\$

У прикладі використано \( f(x) = x^2 \) на відрізку \([0, 2]\). Аналітичне значення:
\[\int_0^2 x^2 dx = \frac{2^3 - 0^3}{3} = \frac{8}{3} \approx 2.6666666667.\]

### Як запустити
```bash
python monte_carlo_integral.py --a 0 --b 2 --n 100000 --seed 42
```
Скрипт друкує результат Монте‑Карло, значення `quad` зі SciPy та аналітичний результат. Також зберігає графік `mc_plot.png`.

### Перевірка правильності
- Значення Монте‑Карло збігається з аналітичним та `quad` в межах статистичної похибки, яка зменшується як \( O(1/\sqrt{n}) \).  
- Зі зростанням `n` точність покращується; але збільшується час виконання.

**Висновок:** метод Монте‑Карло коректно оцінює інтеграл і є корисним для високовимірних задач або функцій зі складною формою, де детерміновані методи (як `quad`) стають непридатними або надто повільними. Для одновимірних простих функцій детерміновані методи точніші та швидші.

## Вимоги
```
numpy
scipy
matplotlib
```
